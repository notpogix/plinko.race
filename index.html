<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Marble Maze Race</title>
<!-- Matter.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220cc;
    --accent:#10b981;
    --text:#e6eef8;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  body{background:linear-gradient(180deg,#071021 0%, #071a2a 100%);color:var(--text);display:flex;flex-direction:column;align-items:center;}
  header{width:100%;padding:12px 20px;box-sizing:border-box;display:flex;align-items:center;justify-content:space-between;gap:12px;}
  h1{font-size:18px;margin:0;color:var(--accent);}
  .controls{display:flex;gap:8px;align-items:center;}
  .panel{background:var(--panel);padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,0.6);}
  #ui{position:fixed;right:18px;top:18px;width:220px;z-index:50;}
  #leaderboard{height:220px;overflow:auto;padding:10px;}
  label{font-size:12px;color:#9fb6d0;display:block;margin-bottom:6px;}
  textarea,input,select,button{width:100%;box-sizing:border-box;border-radius:8px;border:1px solid rgba(255,255,255,0.06);padding:8px;background:transparent;color:var(--text);}
  button{cursor:pointer;border:none;background:linear-gradient(90deg,#0ea5a4,#06b6d4);color:#021; font-weight:700;padding:10px;}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);font-weight:600;}
  #canvasWrap{width:100%;max-width:900px;height:1200px;margin:20px auto;border-radius:12px;overflow:hidden;box-shadow:0 10px 40px rgba(2,6,23,0.6);position:relative;}
  canvas{display:block;background:linear-gradient(180deg,#082033 0%, #04121a 100%);}
  .finishLine{position:absolute;left:0;right:0;height:6px;background:linear-gradient(90deg,#f97316,#f43f5e);bottom:40px;z-index:40;}
  .startLine{position:absolute;left:0;right:0;height:6px;background:linear-gradient(90deg,#60a5fa,#7c3aed);top:40px;z-index:40;}
  .meta{position:fixed;left:18px;top:18px;color:#9fb6d0;font-size:13px;}
  .small{font-size:12px;color:#9fb6d0;}
  .nameRow{display:flex;align-items:center;gap:8px;padding:6px;border-radius:6px;margin-bottom:6px;}
  .colorDot{width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#021;}
  .rankLabel{flex:1;font-weight:700;}
  footer{width:100%;padding:12px;text-align:center;color:#9fb6d0;font-size:13px;}
  @media(max-width:720px){
    #canvasWrap{height:1000px;max-width:420px;}
    #ui{position:static;margin:12px;}
    header{flex-direction:column;align-items:flex-start;gap:8px;}
  }
</style>
</head>
<body>
<header>
  <h1>Marble Maze Race</h1>
  <div class="controls">
    <div class="panel" style="min-width:260px;">
      <label>Enter names (one per line)</label>
      <textarea id="namesInput" rows="4" placeholder="Alice&#10;Bob&#10;Charlie"></textarea>
      <div style="display:flex;gap:8px;margin-top:8px;">
        <select id="modeSelect" title="Mode">
          <option value="remove">Remove Winner (keep playing)</option>
          <option value="elimination">Elimination (last out each round)</option>
        </select>
        <button id="startBtn">Start Race</button>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px;">
        <button id="continueBtn" class="secondary">Continue</button>
        <button id="removeWinnerBtn" class="secondary">Remove Winner</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>
      <div style="margin-top:8px;" class="small">Tip: Add many names for a longer, more chaotic race.</div>
    </div>
  </div>
</header>

<div id="canvasWrap" class="panel">
  <div class="startLine"></div>
  <div class="finishLine"></div>
  <canvas id="world"></canvas>
</div>

<div id="ui">
  <div class="panel">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <strong>Leaderboard</strong>
      <span id="roundInfo" class="small">Round 0</span>
    </div>
    <div id="leaderboard"></div>
    <div style="margin-top:8px;">
      <div class="small">Round timer: <span id="timer">00:00</span></div>
      <div class="small">Active balls: <span id="activeCount">0</span></div>
    </div>
  </div>
</div>

<div class="meta panel">
  <div><strong>Mode:</strong> <span id="modeLabel">Remove Winner</span></div>
  <div class="small">Start at top, finish at bottom</div>
</div>

<footer class="panel small">No login required â€” enter names and start. Physics powered by Matter.js</footer>

<script>
/* Marble Maze Race
   Single-file site using Matter.js
   Paste into index.html and open in browser.
*/

// ----- Utilities -----
const COLORS = [
  '#F97316','#F43F5E','#FB7185','#60A5FA','#7C3AED','#34D399','#F59E0B','#06B6D4','#EF4444','#A78BFA',
  '#FDE68A','#34D399','#60A5FA','#F472B6','#FCA5A5','#93C5FD','#C7B3FF'
];
function pickColor(i){ return COLORS[i % COLORS.length]; }
function letterOf(name){ return (name||'').trim().charAt(0).toUpperCase() || '?'; }
function formatTime(s){ const m=Math.floor(s/60), sec=Math.floor(s%60); return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`; }

// ----- Matter.js setup -----
const { Engine, Render, Runner, Bodies, Composite, Composites, Body, Events, Mouse, MouseConstraint, Vector } = Matter;

const canvas = document.getElementById('world');
const canvasWrap = document.getElementById('canvasWrap');
const W = canvasWrap.clientWidth;
const H = canvasWrap.clientHeight;
canvas.width = W;
canvas.height = H;

const engine = Engine.create();
engine.gravity.y = 1.05; // adjustable for pacing
const world = engine.world;
world.bounds = { min: { x: 0, y: 0 }, max: { x: W, y: H } };

const render = Render.create({
  canvas: canvas,
  engine: engine,
  options: {
    width: W,
    height: H,
    wireframes: false,
    background: 'transparent',
    showAngleIndicator: false
  }
});
Render.run(render);
const runner = Runner.create();
Runner.run(runner, engine);

// ----- Static walls -----
const wallThickness = 60;
const walls = [
  Bodies.rectangle(W/2, -wallThickness/2, W, wallThickness, { isStatic:true }),
  Bodies.rectangle(W/2, H + wallThickness/2, W, wallThickness, { isStatic:true }),
  Bodies.rectangle(-wallThickness/2, H/2, wallThickness, H, { isStatic:true }),
  Bodies.rectangle(W + wallThickness/2, H/2, wallThickness, H, { isStatic:true })
];
Composite.add(world, walls);

// Finish line sensor (y coordinate)
const finishY = H - 60;

// ----- Peg / maze generator -----
function generatePegs(rows=18, cols=10, spacingX= W / (cols+1), spacingY = (H-160)/rows) {
  const pegs = [];
  const startY = 120;
  for (let r=0;r<rows;r++){
    const offset = (r % 2 === 0) ? spacingX/2 : 0;
    for (let c=0;c<cols;c++){
      const x = Math.max(40, Math.min(W-40, (c+1)*spacingX + offset));
      const y = startY + r*spacingY + (Math.random()*spacingY*0.25);
      const peg = Bodies.circle(x, y, 8 + Math.random()*6, {
        isStatic: true,
        render: { fillStyle: '#94a3b8' }
      });
      pegs.push(peg);
    }
  }
  return pegs;
}
let pegs = generatePegs(22, 12); // dense, long map
Composite.add(world, pegs);

// Add some angled obstacles / ramps
function addRamps(){
  const ramps = [];
  ramps.push(Bodies.rectangle(W*0.25, H*0.45, W*0.5, 12, { isStatic:true, angle: -0.25, render:{fillStyle:'#334155'} }));
  ramps.push(Bodies.rectangle(W*0.75, H*0.65, W*0.5, 12, { isStatic:true, angle: 0.18, render:{fillStyle:'#334155'} }));
  Composite.add(world, ramps);
}
addRamps();

// ----- Ball management -----
let balls = []; // { body, name, color, letter, finishedAt, id }
let nextBallId = 1;
const ballRadius = 18;
const startXRange = [60, W-60];
const startY = 60;

function createBall(name, color){
  const x = startXRange[0] + Math.random()*(startXRange[1]-startXRange[0]);
  const body = Bodies.circle(x, startY + Math.random()*6, ballRadius, {
    restitution: 0.3,
    friction: 0.02,
    frictionAir: 0.002,
    density: 0.002,
    label: 'ball',
    render: { fillStyle: color }
  });
  body.customId = nextBallId++;
  const b = { body, name, color, letter: letterOf(name), finishedAt: null, id: body.customId };
  balls.push(b);
  Composite.add(world, body);
  return b;
}

function clearBalls(){
  balls.forEach(b => Composite.remove(world, b.body));
  balls = [];
  nextBallId = 1;
}

// ----- Leaderboard UI -----
const leaderboardEl = document.getElementById('leaderboard');
const activeCountEl = document.getElementById('activeCount');
const roundInfoEl = document.getElementById('roundInfo');
const timerEl = document.getElementById('timer');
const modeLabelEl = document.getElementById('modeLabel');

function updateLeaderboard(){
  // Rank by distance to finish (higher y is closer to finish)
  const active = balls.filter(b => b.finishedAt === null);
  const ranked = [...balls].sort((a,b) => {
    const ay = a.body.position.y;
    const by = b.body.position.y;
    // finished ones should be at top by finish time
    if (a.finishedAt !== null && b.finishedAt === null) return -1;
    if (b.finishedAt !== null && a.finishedAt === null) return 1;
    if (a.finishedAt !== null && b.finishedAt !== null) return a.finishedAt - b.finishedAt;
    return by - ay;
  });
  leaderboardEl.innerHTML = '';
  ranked.forEach((b, idx) => {
    const row = document.createElement('div');
    row.className = 'nameRow';
    const dot = document.createElement('div');
    dot.className = 'colorDot';
    dot.style.background = b.color;
    dot.textContent = b.letter;
    const label = document.createElement('div');
    label.className = 'rankLabel';
    const status = b.finishedAt ? `Finished (#${b.finishedAtRank || idx+1})` : `In race`;
    label.innerHTML = `<div style="font-weight:800">${b.name}</div><div class="small">${status}</div>`;
    row.appendChild(dot);
    row.appendChild(label);
    leaderboardEl.appendChild(row);
  });
  activeCountEl.textContent = active.length;
}

// ----- Finish detection -----
let finishOrder = []; // array of ball ids in order they crossed
Events.on(engine, 'afterUpdate', function(){
  balls.forEach(b => {
    if (b.finishedAt === null && b.body.position.y >= finishY - 10) {
      b.finishedAt = performance.now();
      finishOrder.push(b);
      b.finishedAtRank = finishOrder.length;
      // make ball static at finish area to avoid bouncing out
      Body.setVelocity(b.body, { x:0, y:0 });
      Body.setStatic(b.body, true);
    }
  });
  updateLeaderboard();
});

// ----- Drawing letters on balls -----
(function patchRender(){
  const original = render.context;
  // We'll draw letters after the engine renders
  Events.on(render, 'afterRender', function(){
    const ctx = render.context;
    balls.forEach(b => {
      const pos = b.body.position;
      ctx.beginPath();
      ctx.fillStyle = b.color;
      ctx.arc(pos.x, pos.y, ballRadius, 0, Math.PI*2);
      ctx.fill();
      // outline
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.stroke();
      // letter
      ctx.fillStyle = '#021';
      ctx.font = `${ballRadius}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.letter, pos.x, pos.y+1);
    });
    // draw start/finish labels
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(0, finishY, render.options.width, 4);
  });
})();

// ----- Controls and game flow -----
const namesInput = document.getElementById('namesInput');
const startBtn = document.getElementById('startBtn');
const continueBtn = document.getElementById('continueBtn');
const removeWinnerBtn = document.getElementById('removeWinnerBtn');
const resetBtn = document.getElementById('resetBtn');
const modeSelect = document.getElementById('modeSelect');

let originalNames = [];
let activeNames = [];
let round = 0;
let roundStartTime = null;
let roundTimerInterval = null;
let mode = 'remove'; // or 'elimination'
let roundInProgress = false;

function assignColorsToNames(names){
  return names.map((n,i) => ({ name: n.trim(), color: pickColor(i) }));
}

function startRaceFromNames(namesArr){
  // clear previous balls and finish order
  clearBalls();
  finishOrder = [];
  round++;
  roundStartTime = performance.now();
  roundInProgress = true;
  roundInfoEl.textContent = `Round ${round}`;
  // create balls
  namesArr.forEach((n,i) => {
    const color = pickColor(i);
    createBall(n, color);
  });
  // ensure pegs are present; if not, regenerate
  updateLeaderboard();
  startRoundTimer();
}

function startRoundTimer(){
  if (roundTimerInterval) clearInterval(roundTimerInterval);
  roundTimerInterval = setInterval(() => {
    const elapsed = (performance.now() - roundStartTime)/1000;
    timerEl.textContent = formatTime(elapsed);
    // If round is taking too long, slightly increase gravity to finish within target
    if (elapsed > 70 && engine.gravity.y < 1.6) engine.gravity.y += 0.02;
    // If round is too short, reduce gravity for next rounds
  }, 500);
}

function stopRoundTimer(){
  if (roundTimerInterval) clearInterval(roundTimerInterval);
  roundTimerInterval = null;
  timerEl.textContent = '00:00';
}

function beginGame(){
  // parse names
  const raw = namesInput.value.split('\n').map(s => s.trim()).filter(Boolean);
  if (raw.length < 1) {
    alert('Please enter at least one name.');
    return;
  }
  originalNames = raw.slice();
  activeNames = raw.slice();
  round = 0;
  mode = modeSelect.value;
  modeLabelEl.textContent = mode === 'remove' ? 'Remove Winner' : 'Elimination';
  // regenerate pegs for variety
  Composite.remove(world, pegs);
  pegs = generatePegs(22, 12);
  Composite.add(world, pegs);
  // reset gravity
  engine.gravity.y = 1.05;
  startRaceFromNames(activeNames);
}

startBtn.addEventListener('click', () => {
  beginGame();
});

// Continue (start next round with current active names)
continueBtn.addEventListener('click', () => {
  if (activeNames.length <= 1) {
    alert('Not enough players to continue.');
    return;
  }
  // regenerate pegs and reset world positions of balls
  Composite.remove(world, pegs);
  pegs = generatePegs(22, 12);
  Composite.add(world, pegs);
  engine.gravity.y = 1.05;
  startRaceFromNames(activeNames);
});

// Remove winner manually
removeWinnerBtn.addEventListener('click', () => {
  if (finishOrder.length === 0) {
    alert('No winner yet. Wait until someone finishes.');
    return;
  }
  const winner = finishOrder[0];
  if (!winner) return;
  // remove winner from activeNames
  activeNames = activeNames.filter(n => n !== winner.name);
  // remove winner ball from world
  Composite.remove(world, winner.body);
  balls = balls.filter(b => b !== winner);
  finishOrder = finishOrder.slice(1);
  updateLeaderboard();
  if (activeNames.length <= 1) {
    stopRoundTimer();
    roundInProgress = false;
    alert(`Winner removed. Final winner: ${activeNames[0] || 'None'}`);
  } else {
    // continue with remaining players
    alert(`${winner.name} removed. ${activeNames.length} players remain.`);
  }
});

// Reset everything
resetBtn.addEventListener('click', () => {
  if (!confirm('Reset the game and clear names?')) return;
  clearBalls();
  Composite.remove(world, pegs);
  pegs = generatePegs(22, 12);
  Composite.add(world, pegs);
  namesInput.value = '';
  originalNames = [];
  activeNames = [];
  round = 0;
  finishOrder = [];
  stopRoundTimer();
  updateLeaderboard();
});

// Automatic elimination logic: when all balls finished, handle according to mode
Events.on(engine, 'afterUpdate', function(){
  if (!roundInProgress) return;
  // if all balls finished
  const unfinished = balls.filter(b => b.finishedAt === null);
  if (unfinished.length === 0 && balls.length > 0) {
    roundInProgress = false;
    stopRoundTimer();
    // finishOrder contains balls in order of crossing
    // assign ranks
    finishOrder.forEach((b, idx) => b.finishedAtRank = idx+1);
    updateLeaderboard();
    if (mode === 'remove') {
      // do nothing automatic; user can press Remove Winner to continue
      alert(`Round ${round} finished. Winner: ${finishOrder[0].name}. Press "Remove Winner" to remove and continue.`);
    } else if (mode === 'elimination') {
      // eliminate last finisher
      const last = finishOrder[finishOrder.length - 1];
      if (last) {
        alert(`Round ${round} finished. Eliminated: ${last.name}`);
        // remove from activeNames
        activeNames = activeNames.filter(n => n !== last.name);
      }
      // if more than one remains, restart automatically after short delay
      if (activeNames.length > 1) {
        setTimeout(() => {
          // regenerate pegs for next round
          Composite.remove(world, pegs);
          pegs = generatePegs(22, 12);
          Composite.add(world, pegs);
          engine.gravity.y = 1.05;
          startRaceFromNames(activeNames);
        }, 1200);
      } else {
        alert(`Final winner: ${activeNames[0] || 'None'}`);
      }
    }
  }
});

// Keep canvas responsive on resize
window.addEventListener('resize', () => {
  const newW = canvasWrap.clientWidth;
  const newH = canvasWrap.clientHeight;
  render.canvas.width = newW;
  render.canvas.height = newH;
  render.options.width = newW;
  render.options.height = newH;
});

// initial UI update
updateLeaderboard();
</script>
</body>
</html>
